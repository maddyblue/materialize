// Copyright Materialize, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

// BEGIN LINT CONFIG
// DO NOT EDIT. Automatically generated by bin/gen-lints.
// Have complaints about the noise? See the note in misc/python/materialize/cli/gen-lints.py first.
#![allow(clippy::style)]
#![allow(clippy::complexity)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::mutable_key_type)]
#![allow(clippy::stable_sort_primitive)]
#![allow(clippy::map_entry)]
#![allow(clippy::box_default)]
#![warn(clippy::bool_comparison)]
#![warn(clippy::clone_on_ref_ptr)]
#![warn(clippy::no_effect)]
#![warn(clippy::unnecessary_unwrap)]
#![warn(clippy::dbg_macro)]
#![warn(clippy::todo)]
#![warn(clippy::wildcard_dependencies)]
#![warn(clippy::zero_prefixed_literal)]
#![warn(clippy::borrowed_box)]
#![warn(clippy::deref_addrof)]
#![warn(clippy::double_must_use)]
#![warn(clippy::double_parens)]
#![warn(clippy::extra_unused_lifetimes)]
#![warn(clippy::needless_borrow)]
#![warn(clippy::needless_question_mark)]
#![warn(clippy::needless_return)]
#![warn(clippy::redundant_pattern)]
#![warn(clippy::redundant_slicing)]
#![warn(clippy::redundant_static_lifetimes)]
#![warn(clippy::single_component_path_imports)]
#![warn(clippy::unnecessary_cast)]
#![warn(clippy::useless_asref)]
#![warn(clippy::useless_conversion)]
#![warn(clippy::builtin_type_shadow)]
#![warn(clippy::duplicate_underscore_argument)]
#![warn(clippy::double_neg)]
#![warn(clippy::unnecessary_mut_passed)]
#![warn(clippy::wildcard_in_or_patterns)]
#![warn(clippy::crosspointer_transmute)]
#![warn(clippy::excessive_precision)]
#![warn(clippy::overflow_check_conditional)]
#![warn(clippy::as_conversions)]
#![warn(clippy::match_overlapping_arm)]
#![warn(clippy::zero_divided_by_zero)]
#![warn(clippy::must_use_unit)]
#![warn(clippy::suspicious_assignment_formatting)]
#![warn(clippy::suspicious_else_formatting)]
#![warn(clippy::suspicious_unary_op_formatting)]
#![warn(clippy::mut_mutex_lock)]
#![warn(clippy::print_literal)]
#![warn(clippy::same_item_push)]
#![warn(clippy::useless_format)]
#![warn(clippy::write_literal)]
#![warn(clippy::redundant_closure)]
#![warn(clippy::redundant_closure_call)]
#![warn(clippy::unnecessary_lazy_evaluations)]
#![warn(clippy::partialeq_ne_impl)]
#![warn(clippy::redundant_field_names)]
#![warn(clippy::transmutes_expressible_as_ptr_casts)]
#![warn(clippy::unused_async)]
#![warn(clippy::disallowed_methods)]
#![warn(clippy::disallowed_macros)]
#![warn(clippy::disallowed_types)]
#![warn(clippy::from_over_into)]
// END LINT CONFIG

//! Utility functions for S3.

// Copyright Materialize, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

use std::collections::BTreeMap;
use std::io::prelude::*;
use std::path::PathBuf;
use std::time::Duration;

use aws_credential_types::Credentials;
use aws_sdk_s3::config::Region;
use aws_sdk_s3::Client;
use aws_sdk_s3::Config;
use openssl::symm::decrypt;
use openssl::symm::Cipher;
use serde::Deserialize;
use url::Url;

use mz_ore::retry::Retry;

pub async fn copy_fetch_s3(
    url: Url,
    credentials: &str,
    region: Option<&str>,
    gzip: bool,
    encrypted: bool,
    manifest: bool,
) -> Result<Vec<Vec<u8>>, anyhow::Error> {
    let mut creds = BTreeMap::new();
    for s in credentials.split(';') {
        let Some((key, val)) = s.split_once('=') else {
            anyhow::bail!("misformatted CREDENTIALS");
        };
        creds.insert(key, val.to_string());
    }
    let Some(aws_access_key_id) = creds.remove("aws_access_key_id") else {
        anyhow::bail!("CREDENTIALS missing aws_access_key_id");
    };
    let Some(aws_secret_access_key) = creds.remove("aws_secret_access_key") else {
        anyhow::bail!("CREDENTIALS missing aws_secret_access_key");
    };
    let session_token = creds.remove("token");
    let master_symmetric_key = if encrypted {
        let Some(master_symmetric_key) = creds.remove("master_symmetric_key") else {
            anyhow::bail!("CREDENTIALS missing master_symmetric_key");
        };
        Some(master_symmetric_key)
    } else {
        None
    };

    let creds = Credentials::from_keys(aws_access_key_id, aws_secret_access_key, session_token);
    let config = Config::builder()
        .credentials_provider(creds)
        .region(region.map(|r| Region::new(r.to_owned())))
        .build();
    let client = Client::from_conf(config);

    let manifest: CopyManifest = if manifest {
        let manifest = fetch_s3_file(&client, &url).await?;
        serde_json::from_slice(&manifest.body(master_symmetric_key.as_deref())?)?
    } else {
        CopyManifest {
            entries: vec![CopyManifestEntry {
                url,
                mandatory: true,
            }],
        }
    };

    let mut files = Vec::new();
    for entry in manifest.entries {
        match fetch_s3_file(&client, &entry.url).await {
            Ok(file) => {
                let contents = file.body(master_symmetric_key.as_deref())?;
                let contents = if gzip {
                    let mut buf = Vec::new();
                    flate2::read::GzDecoder::new(&*contents).read_to_end(&mut buf)?;
                    buf
                } else {
                    contents
                };
                files.push(contents);
            }
            Err(err) => {
                if !entry.mandatory {
                    anyhow::bail!("non-mandatory COPY manifest files not supported");
                }
                // Detect errors for non-mandatory files that don't exist.
                /*
                if let aws_sdk_s3::error::SdkError::ServiceError(e) = &err {
                    if !entry.mandatory
                        && matches!(
                            e.err(),
                            aws_sdk_s3::operation::get_object::GetObjectError::NoSuchKey(_)
                        )
                    {
                        continue;
                    }
                }
                */
                return Err(err);
            }
        };
    }
    Ok(files)
}

#[derive(Debug)]
struct S3File {
    raw_body: Vec<u8>,
    metadata: BTreeMap<String, String>,
}

impl S3File {
    // Returns and possibly decrypts the file. master_symmetric_key can be a base64-encoded master
    // key.
    fn body(&self, master_symmetric_key: Option<&str>) -> Result<Vec<u8>, anyhow::Error> {
        // See
        // https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/services/s3/package-summary.html
        // for descriptions of the metadata format.

        // V1
        if let Some(key) = self.metadata.get("x-amz-key") {
            let Some(iv) = self.metadata.get("x-amz-iv") else {
                anyhow::bail!("expected s3 iv in metadata");
            };
            let iv = aws_smithy_types::base64::decode(iv)?;
            let key = aws_smithy_types::base64::decode(key)?;
            let Some(master_symmetric_key) = master_symmetric_key else {
                anyhow::bail!("expected master symmetric key when decoding encrypted s3 file");
            };
            let master_symmetric_key = aws_smithy_types::base64::decode(master_symmetric_key)?;

            // These slightly differ!
            let key_cipher = Cipher::aes_256_ecb();
            let data_cipher = Cipher::aes_256_cbc();

            let unencrypted_key = decrypt(key_cipher, &master_symmetric_key, None, &key)?;
            let decrypted_body = decrypt(data_cipher, &unencrypted_key, Some(&iv), &self.raw_body)?;
            Ok(decrypted_body)
        } else if let Some(_key) = self.metadata.get("x-amz-key-v2") {
            anyhow::bail!("key-v2 unsupported");
        } else {
            return Ok(self.raw_body.clone());
        }
    }
}

// Fetches a file with retries.
async fn fetch_s3_file(client: &Client, url: &Url) -> Result<S3File, anyhow::Error> {
    if url.scheme() != "s3" {
        anyhow::bail!("expected s3 url scheme");
    }
    let Some(bucket) = url.host_str().map(|s| s.to_owned()) else {
        anyhow::bail!("url has no host");
    };
    let mut key = url.path().to_string();
    if key.starts_with('/') {
        key.remove(0);
    }

    // The retry numbers are made up here.
    Retry::default()
        .max_duration(Duration::from_secs(30))
        .retry_async_canceling(|_state| {
            if _state.i > 0 {
                println!("fetch s3 retry {}", _state.i);
            }
            let bucket = bucket.clone();
            let key = key.clone();
            async {
                let file = client
                    .get_object()
                    .bucket(bucket)
                    .key(key.clone())
                    .send()
                    .await?;
                let mut metadata = BTreeMap::new();
                if let Some(map) = file.metadata() {
                    metadata.extend(map.iter().map(|(k, v)| (k.clone(), v.clone())));
                }
                let body = file.body.collect().await.map(|data| data.to_vec())?;
                let mut path = PathBuf::new();
                path.set_file_name(key);
                let path = PathBuf::from("./s3").join(path);
                std::fs::create_dir_all(path.parent().unwrap()).unwrap();
                std::fs::write(path, &body).unwrap();
                Ok(S3File {
                    metadata,
                    raw_body: body,
                })
            }
        })
        .await
}

#[derive(Deserialize, Debug)]
struct CopyManifest {
    entries: Vec<CopyManifestEntry>,
}

#[derive(Deserialize, Debug)]
struct CopyManifestEntry {
    url: url::Url,
    #[serde(default)]
    mandatory: bool,
}

#[cfg(test)]
mod tests {
    use aws_sdk_s3::primitives::ByteStream;
    use mz_ore::collections::CollectionExt;

    use super::*;

    #[tokio::test]
    async fn test_copy_fetch_s3() {
        let aws_access_key_id = "AKIAV2KIV5LPZML2LK5W";
        let aws_secret_access_key = "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";
        {
            let creds = Credentials::from_keys(aws_access_key_id, aws_secret_access_key, None);
            let config = Config::builder()
                .region(Region::new("us-east-1"))
                .credentials_provider(creds)
                .build();
            let client = Client::from_conf(config);
            let data = ByteStream::read_from()
                .path("/home/mjibson/materialize/s3/0d1026c6-bbd3-4d2d-b357-c702709cdcb6/1")
                .build()
                .await
                .unwrap();
            client
                .put_object()
                .bucket("mjibson-fivetran-redshift")
                .key("1")
                .metadata("x-amz-iv", "+BvlAXtCm0gliRSATj6KWg==")
                .metadata("x-amz-unencrypted-content-length", "116")
                .metadata("x-amz-matdesc", "{}")
                .metadata(
                    "x-amz-key",
                    "FwrzhdrFkDSChILd2IziAKvQNaMHjbgBKZV8Xo4X5iMwoNJ+uLYsnZDJiGIahKxK",
                )
                .body(data)
                .send()
                .await
                .unwrap();
        }

        const URL: &str = "s3://mjibson-fivetran-redshift/upload.manifest";
        let credentials  =format!( "aws_access_key_id={aws_access_key_id};aws_secret_access_key={aws_secret_access_key};master_symmetric_key=Q9pyhzlDPZlZZ1Y99tFHf5rY8Ldqkvs4qG1I4Eeg/p8=");
        let files = copy_fetch_s3(
            url::Url::parse(URL).unwrap(),
            &credentials,
            Some("us-east-1"),
            true,
            true,
            true,
        )
        .await
        .unwrap();
        let file = files.into_element();
        let s = String::from_utf8(file).unwrap();
        println!("{s}");
    }

    #[test]
    fn test_decrypt_s3() {
        let data =
            std::fs::read("/home/mjibson/materialize/s3/0d1026c6-bbd3-4d2d-b357-c702709cdcb6/1")
                .unwrap();
        let master_key = "Q9pyhzlDPZlZZ1Y99tFHf5rY8Ldqkvs4qG1I4Eeg/p8=";

        let f = S3File {
            raw_body: data,
            metadata: BTreeMap::from_iter([
                ("x-amz-iv".into(), "+BvlAXtCm0gliRSATj6KWg==".into()),
                ("x-amz-unencrypted-content-length".into(), "116".into()),
                ("x-amz-matdesc".into(), "{}".into()),
                (
                    "x-amz-key".into(),
                    "FwrzhdrFkDSChILd2IziAKvQNaMHjbgBKZV8Xo4X5iMwoNJ+uLYsnZDJiGIahKxK".into(),
                ),
            ]),
        };

        let d = f.body(Some(master_key)).unwrap();
        let mut buf = String::new();
        flate2::read::GzDecoder::new(&*d)
            .read_to_string(&mut buf)
            .unwrap();
    }
}
